#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# :noTabs=true:

# (c) Copyright Rosetta Commons Member Institutions.
# (c) This file is part of the Rosetta software suite and is made available under license.
# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
# (c) addressed to University of Washington CoMotion, email: license@uw.edu.

## @file  __init__.py
## @brief convenience functions for multi-step scientific tests
## @author Sergey Lyskov


import json, inspect, os.path

import benchmark.hpc_drivers

import benchmark.tests

from benchmark.tests import execute, to_bytes
from benchmark.tests import _StateKey_, _ResultsKey_, _LogKey_
from benchmark.tests import _S_passed_, _S_failed_, _S_build_failed_, _S_script_failed_
from benchmark.tests import _multi_step_config_, _multi_step_error_, _multi_step_result_

__all__ = ['execute', 'to_bytes',
           'config', 'error', 'build_rosetta', 'calculate_extension', 'hpc_driver',
           '_S_passed_', '_S_failed_', '_S_build_failed_', '_S_script_failed_',
           '_StateKey_', '_ResultsKey_', '_LogKey_',
           '_multi_step_config_', '_multi_step_error_', '_multi_step_result_',
]


def config():
    ''' read and parse `config.json` and return it content
    '''
    with open(_multi_step_config_) as f: return json.load(f)


def error(code, message):
    ''' terminate excution of current multi-step test and return control to benchmark-daemon/emulation-script
    '''
    with open(_multi_step_error_, 'w') as f:
        r = { _StateKey_ : _S_build_failed_,  _ResultsKey_ : {}, _LogKey_ : message}
        f.write( json.dump(r, f, sort_keys=True, indent=2) )

    sys.exit(1)


def build_rosetta(mode='release'):
    ''' Compile Rosetta binaries on configured platform and return (res, output, build_command_line) '''
    c = config()
    return benchmark.tests.build_rosetta(c['rosetta_dir'], c['platform'], c, mode=mode, build_unit=False, verbose=False)


def build_and_install_pyrosetta(mode='Release'):
    ''' Compile PyRosetta on configured platform and install it into current virtual environment and return (res, output, build_command_line) '''
    c = config()

    pyrosetta_package_path = c['python_virtual_environment']['root'] + '/.pyrosetta_package'

    options = f'--create-package {pyrosetta_package_path}' + ( ' -sd' if c.get('skip_compile', False) else '' )
    r = benchmark.tests.build_pyrosetta(rosetta_dir=c['rosetta_dir'], platform=c['platform'], jobs=c['cpu_count'], config=c, mode=mode, options=options, skip_compile=False)

    if not r.exitcode: execute('Installing PyRosetta...', f'cd {pyrosetta_package_path}/setup && {c["python_virtual_environment"]["python"]} setup.py install')

    #if not c['emulation']: shutil.rmtree(pyrosetta_package_path)

    return r.exitcode, r.output, r.command_line



def calculate_extension(mode='release'):
    ''' Calculate and return extension for Rosetta executables that will match one generated by scons '''
    c = config()
    return benchmark.tests.calculate_extension(c['platform'], mode=mode)



_hpc_driver_ = None
def hpc_driver():
    global _hpc_driver_

    if _hpc_driver_ is None:
        c = config()
        _hpc_driver_ = eval('benchmark.hpc_drivers.'+ c['hpc_driver'] + '_HPC_Driver')(c['working_dir'], c, tracer=print, set_daemon_message=lambda x:None)

    return _hpc_driver_



def get_script_output_file_name(script_name):
    return os.path.basename(script_name)[:-len('.py')] + '.output.json'


def find_privious_script_name(script_name):
    ''' return name of previous step-by-step script or None if this script is the first one
    '''
    scripts = sorted( f for f in os.listdir(config()['working_dir']) if f[0].isdigit() and f.endswith('.py') )

    if script_name in scripts:
        index = scripts.index(script_name)
        if index > 0: return scripts[index-1]

    return None


def save_variables(variable_names=None):
    ''' Save caller global variable into appropriate json file.
        `variable_names` should be a string listing variable names separated by space. If no `variable_names` argument is specified then all variables is saved.
    '''
    caller_frame_variables = inspect.stack()[1][0].f_globals

    script_name = caller_frame_variables['__file__']
    file_name = get_script_output_file_name(script_name)

    print( f'Saving {script_name} variables to {file_name}...' )

    #print( f'{script_name} globals:', caller_frame_variables)

    #banned_types = [type(json), type(lambda:0)]
    supported_types = [bool, int, float, str, list, dict]

    vs = { name:value for name, value in caller_frame_variables.items() if not name.startswith('_')  and type(value) in supported_types and (True if variable_names is None else name in variable_names.split() ) }

    js = json.dumps(vs, sort_keys=True, indent=2)
    with open(config()['working_dir'] + '/' + file_name, 'w') as f: json.dump(vs, f, sort_keys=True, indent=2)

    print(f'Saved variables: {list(vs.keys())}')



def load_variables():
    caller_frame_variables = inspect.stack()[1][0].f_globals

    script_name = caller_frame_variables['__file__']

    previous_script_variable_file =  get_script_output_file_name( find_privious_script_name(script_name) )

    if previous_script_variable_file:
        with open( config()['working_dir'] + '/' + previous_script_variable_file ) as f: vs = json.load(f)
        caller_frame_variables.update(vs)
        print(f'Loaded variables from {previous_script_variable_file}: {vs.keys()}')




def parse_score_file(score_file_data, sort_by='total_score'):
    ''' parse Rosetta score file data and return score_table_keys, score_table
        where score_table is a [ dict(score_term=value) ]
    '''

    lines = filter(lambda l: l.startswith('SCORE:'),  score_file.split('\n'))

    if len(lines) < 1: return [], []

    score_table_keys = lines[0].split()[1:]
    score_table_keys[-1] = 'decoy'  # changing description â†’ decoy

    #lines = sorted(filter(lambda l: l and l.split()[0] == 'SCORE:', lines[1:]), key=lambda l: float(l.split()[1]) )   # sorting lines by score
    lines = filter(lambda l: l and l.split()[0] == 'SCORE:', lines[1:])

    #score_table = dict([(k,[]) for k in keys])
    def tryFloat(v):
        try: return float(v)
        except ValueError: return v

    score_table = [ dict( zip(score_table_keys, map(tryFloat, l.split()[1:])) )  for l in lines]

    score_table = sorted(score_table, key=lambda r: r[sort_by] if sort_by in r else 9.9+999 )

    score_table_keys = score_table_keys[-1:] + score_table_keys[:-1]  # making 'decoy' the first column

    def sorting_key(value):
        if value == sort_by: return '{:04d}-{}'.format(score_table_keys.index(value), value)
        else: return 'x{:04d}'.format(score_table_keys.index(value))

    #print score_table_keys
    #print [(k, sorting_key(k)) for k in score_table_keys], '\n\n'
    score_table_keys = score_table_keys[:1] + sorted(score_table_keys[1:], key=sorting_key)

    return score_table_keys, score_table
